# TR-01: Stack-Allocated Locals and Phi Nodes for Control Flow

**Date:** 2026-02-07
**Author:** WAQ Development Team
**Status:** Implemented and Tested

## Abstract

This technical report documents the implementation of two critical features in the WAQ WebAssembly-to-QBE compiler: stack-allocated local variables and phi nodes for if/else blocks with result values. These features enable correct compilation of programs with mutable locals across control flow boundaries, including loops and recursive functions.

## 1. Problem Statement

### 1.1 Loop-Carried Values

WebAssembly uses a stack-based virtual machine with mutable local variables. The initial WAQ implementation mapped locals directly to SSA (Static Single Assignment) temporaries:

```
; WASM: local.get 0
%t0 =w copy %local0

; WASM: local.set 0
%local0 =w copy %t1
```

This approach fails for loop-carried values because SSA temporaries cannot be reassigned. Consider a simple loop summing 1 to 10:

```wat
(func (result i32)
  (local $sum i32) (local $i i32)
  (local.set $i (i32.const 1))
  (block $break
    (loop $continue
      ;; sum = sum + i
      (local.set $sum (i32.add (local.get $sum) (local.get $i)))
      ;; i = i + 1
      (local.set $i (i32.add (local.get $i) (i32.const 1)))
      ;; if i <= 10, continue
      (br_if $continue (i32.le_s (local.get $i) (i32.const 10)))
    )
  )
  (local.get $sum)
)
```

With pure SSA, each `local.set` creates a new temporary, but the loop body cannot reference the updated value on the next iteration.

### 1.2 If/Else with Results

WebAssembly's `if` instruction can produce result values:

```wat
(if (result i32) (local.get $n)
  (then (i32.const 1))           ;; returns 1
  (else (i32.mul ...))           ;; returns n * factorial(n-1)
)
```

Both branches produce a value, and the enclosing code expects a single result. In SSA form, different branches produce different temporaries (e.g., `%t3` from then, `%t9` from else), requiring phi nodes at the merge point.

## 2. Solution Design

### 2.1 Stack-Allocated Locals

Instead of mapping locals to SSA temporaries, we allocate stack slots for all locals and use load/store operations:

```
@entry
    %local_addr0 =l alloc4 4      ; Allocate 4 bytes for i32 local
    storew %p0, %local_addr0      ; Initialize from parameter

    %t0 =w loadw %local_addr0     ; local.get 0
    storew %t1, %local_addr0      ; local.set 0
```

This approach:
- Allows mutation: stores overwrite previous values
- Works across control flow: the address is stable, loads get current value
- Matches how traditional compilers handle mutable variables

### 2.2 Phi Nodes for If/Else Results

For if/else blocks with result types, we emit QBE phi instructions at the merge point:

```
@then0
    %t3 =w copy 1
    jmp @if_end2

@else1
    ...
    %t9 =w mul %t4, %t8
    jmp @if_end2

@if_end2
    %t10 =w phi @then0 %t3, @else1 %t9
    ret %t10
```

The phi node selects the appropriate value based on which predecessor block executed.

## 3. Implementation Details

### 3.1 Changes to FunctionContext

The `FunctionContext` class was modified to track local addresses instead of temporaries:

```python
@dataclass
class FunctionContext:
    # Changed from local_temps to local_addrs
    local_addrs: dict[int, str] = field(default_factory=dict)

    def set_local_addr(self, idx: int, addr_name: str) -> None:
        self.local_addrs[idx] = addr_name

    def get_local_addr(self, idx: int) -> str:
        return self.local_addrs[idx]
```

### 3.2 Changes to ControlFrame

The `ControlFrame` dataclass was extended to track then-branch values for phi generation:

```python
@dataclass
class ControlFrame:
    # ... existing fields ...

    # For if/else with results: store values from then branch
    then_values: list[str] | None = None
    then_label: str | None = None
```

### 3.3 Code Generation for Locals

In `codegen.py`, function entry now allocates stack space:

```python
def _vtype_size(vtype: ValueType) -> int:
    """Get size in bytes for a value type."""
    if vtype in (ValueType.I32, ValueType.F32):
        return 4
    if vtype in (ValueType.I64, ValueType.F64):
        return 8
    if vtype.is_reference():
        return 8  # Pointers are 64-bit
    raise ValueError(f"unknown value type size: {vtype}")

# In compile_function:
for i, vtype in enumerate(locals_list):
    addr_name = f"local_addr{i}"
    size = _vtype_size(vtype)
    align = 8 if size == 8 else 4
    entry_block.instructions.append(
        Alloc(result=Temporary(addr_name), size=IntConst(size), align=align)
    )
    func_ctx.set_local_addr(i, addr_name)
```

### 3.4 Variable Instructions

In `variable.py`, local access uses load/store:

```python
# local.get - load from stack slot
if opcode == 0x20:
    idx = read_operand("u32")
    vtype = ctx.get_local_type(idx)
    addr_name = ctx.get_local_addr(idx)
    temp = ctx.stack.new_temp(vtype)
    load_type = _vtype_to_load_type(vtype)
    block.instructions.append(
        Load(result=Temporary(temp.name), result_type=qbe_type,
             address=Temporary(addr_name), load_type=load_type)
    )

# local.set - store to stack slot
if opcode == 0x21:
    idx = read_operand("u32")
    value = ctx.stack.pop()
    addr_name = ctx.get_local_addr(idx)
    store_type = _vtype_to_store_type(ctx.get_local_type(idx))
    block.instructions.append(
        Store(value=Temporary(value.name), address=Temporary(addr_name),
              store_type=store_type)
    )
```

### 3.5 Control Flow with Phi Nodes

In `control.py`, the else handler captures then-branch state:

```python
if opcode == 0x05:  # else
    frame = ctx.control_stack[-1]

    if frame.result_types:
        # Capture stack values from then branch
        then_values = []
        for i in range(len(frame.result_types)):
            val = ctx.stack.peek_at(len(frame.result_types) - 1 - i)
            then_values.append(val.name)
        frame.then_values = then_values
        frame.then_label = block.name
        ctx.stack.pop_n(len(frame.result_types))

    # Continue with else block creation...
```

The end handler emits phi nodes:

```python
if opcode == 0x0B:  # end
    frame = ctx.pop_control()

    if frame.kind == "if" and frame.then_values is not None:
        # Capture else branch values
        else_values = [ctx.stack.peek_at(i).name for i in range(len(frame.result_types))]
        else_label_for_phi = block.name
        ctx.stack.pop_n(len(frame.result_types))

        # Create end block with phi nodes
        end_block = func.add_block(frame.label_name.removeprefix("@"))
        for i, vtype in enumerate(frame.result_types):
            phi_result = ctx.stack.new_temp(vtype)
            incoming = [
                (Label(frame.then_label), Temporary(frame.then_values[i])),
                (Label(else_label_for_phi), Temporary(else_values[i])),
            ]
            end_block.phis.append(Phi(
                result=Temporary(phi_result.name),
                result_type=_vtype_to_ir_type(vtype),
                incoming=incoming,
            ))
        return end_block
```

### 3.6 Stack Helper Method

A `peek_at` method was added to `ValueStack`:

```python
def peek_at(self, index: int) -> StackValue:
    """Peek at a value at given index from top (0 = top)."""
    if index >= len(self._stack):
        raise CompileError(f"stack underflow on peek_at({index})")
    return self._stack[-(index + 1)]
```

## 4. Generated Code Examples

### 4.1 Loop (Sum 1 to 10)

```
function w $wasm_main() {
@entry
    %local_addr0 =l alloc4 4      ; sum
    %local_addr1 =l alloc4 4      ; i
    storew 0, %local_addr0
    storew 1, %local_addr1
    jmp @loop0
@loop0
    %t0 =w loadw %local_addr0     ; load sum
    %t1 =w loadw %local_addr1     ; load i
    %t2 =w add %t0, %t1           ; sum + i
    storew %t2, %local_addr0      ; store sum
    %t3 =w loadw %local_addr1     ; load i
    %t4 =w add %t3, 1             ; i + 1
    storew %t4, %local_addr1      ; store i
    %t5 =w loadw %local_addr1     ; load i
    %t6 =w cslew %t5, 10          ; i <= 10
    jnz %t6, @loop0, @block_end1
@block_end1
    %t7 =w loadw %local_addr0     ; load sum
    ret %t7                        ; return 55
}
```

### 4.2 Factorial (Recursive)

```
function w $__wasm_func_0(w %p0) {
@entry
    %local_addr0 =l alloc4 4
    storew %p0, %local_addr0
    %t0 =w loadw %local_addr0
    %t1 =w copy 1
    %t2 =w cslew %t0, %t1         ; n <= 1
    jnz %t2, @then0, @else1
@then0
    %t3 =w copy 1                  ; return 1
    jmp @if_end2
@else1
    %t4 =w loadw %local_addr0      ; n
    %t5 =w loadw %local_addr0      ; n
    %t6 =w copy 1
    %t7 =w sub %t5, %t6            ; n - 1
    %t8 =w call $__wasm_func_0(w %t7)  ; factorial(n-1)
    %t9 =w mul %t4, %t8            ; n * factorial(n-1)
    jmp @if_end2
@if_end2
    %t10 =w phi @then0 %t3, @else1 %t9  ; merge results
    ret %t10
}
```

## 5. Testing

### 5.1 Test Suite

Eight end-to-end tests validate the full compilation pipeline:

| Test | Description | Expected | Status |
|------|-------------|----------|--------|
| test_return_42 | Return constant | 42 | PASS |
| test_add | Addition | 30 | PASS |
| test_locals | Local variables | 30 | PASS |
| test_loop | Sum 1 to 10 | 55 | PASS |
| test_factorial | factorial(6) | 208 (720 % 256) | PASS |
| test_fibonacci | fib(10) | 55 | PASS |
| test_memory | Memory load/store | 100 | PASS |
| test_global | Global counter | 3 | PASS |

### 5.2 Pipeline

Each test follows the complete pipeline:
1. WAT source compiled with `wat2wasm`
2. WASM binary compiled with WAQ to QBE IL
3. QBE IL assembled to native code with `qbe`
4. Assembly linked with runtime using `clang`
5. Executable run and exit code verified

## 6. Performance Considerations

### 6.1 Stack Allocation Overhead

Using stack slots instead of registers introduces memory operations. However:
- QBE's register allocator can promote stack slots to registers when beneficial
- Modern CPUs have fast L1 cache for stack access
- This matches standard compiler practice for mutable variables

### 6.2 Phi Node Efficiency

Phi nodes are a standard SSA construct that QBE handles efficiently. They typically compile to no code (just register renaming) or a single move instruction.

## 7. Limitations and Future Work

### 7.1 Current Limitations

- If without else and results: Not yet implemented (would need default values)
- Multi-value returns: Not yet implemented (Phase 3 feature)
- Block/loop with results: Uses stack restoration, could use phi nodes

### 7.2 Future Optimizations

- Register promotion for locals that don't escape loops
- Phi node elimination for single-predecessor blocks
- Dead store elimination

## 8. Conclusion

The implementation of stack-allocated locals and phi nodes enables WAQ to correctly compile WebAssembly programs with mutable state and complex control flow. The solution is simple, correct, and follows established compiler design patterns. All eight end-to-end tests pass, demonstrating working loops, recursion, and conditional expressions with results.

## References

1. WebAssembly Specification 1.0
2. QBE Intermediate Language Documentation
3. Cytron et al., "Efficiently Computing Static Single Assignment Form and the Control Dependence Graph"
