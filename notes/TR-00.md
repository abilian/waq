# TR-00: WAQ Project Overview

**Date:** 2026-02-07
**Author:** WAQ Development Team
**Version:** 0.1 (Stage 1)

## Abstract

WAQ is an ahead-of-time (AOT) compiler that translates WebAssembly binary modules into native machine code using QBE as the backend. This technical report provides a comprehensive overview of the project's architecture, design decisions, and implementation details.

## 1. Introduction

### 1.1 Project Goals

WAQ aims to provide a simple, correct, and portable WebAssembly compiler with the following priorities:

1. **Correctness** - Faithful implementation of WebAssembly semantics
2. **Simplicity** - Clean, maintainable codebase
3. **Portability** - Support for multiple architectures via QBE
4. **Progressive Implementation** - Starting with WASM 1.0, extending to 2.0 features

### 1.2 Why QBE?

QBE (Quick Backend Engine) is a lightweight compiler backend that provides:
- Simple intermediate language (IL)
- Good code quality with minimal complexity
- Support for x86-64, ARM64, and RISC-V 64
- Fast compilation times
- SSA-based optimizations

### 1.3 Key Transformations

The compiler performs two fundamental transformations:

| WebAssembly | QBE |
|-------------|-----|
| Stack machine | SSA with temporaries |
| Structured control flow (block/loop/if) | CFG with basic blocks and jumps |

Type mapping:
- `i32` → `w` (word, 32-bit)
- `i64` → `l` (long, 64-bit)
- `f32` → `s` (single precision)
- `f64` → `d` (double precision)
- Reference types → `l` (64-bit pointers)

## 2. Architecture Overview

### 2.1 Project Structure

```
src/waq/
├── __init__.py          # Package entry point
├── cli.py               # Command-line interface
├── errors.py            # Error definitions
├── parser/              # WASM binary parsing
│   ├── binary.py        # LEB128 and binary reading
│   ├── types.py         # WASM type definitions
│   └── module.py        # Module representation
├── compiler/            # Code generation
│   ├── codegen.py       # Main compilation logic
│   ├── context.py       # Compilation contexts
│   ├── stack.py         # Value stack simulation
│   └── instructions/    # Instruction compilers
│       ├── control.py   # Control flow
│       ├── numeric.py   # Arithmetic/logic
│       ├── memory.py    # Memory operations
│       ├── variable.py  # Local/global access
│       ├── conversion.py # Type conversions
│       ├── reference.py # Reference types
│       ├── table.py     # Table operations
│       ├── exceptions.py # Exception handling
│       └── gc.py        # GC operations
└── runtime/             # Runtime library interface
    └── __init__.py

runtime/                 # C runtime library
├── wasm_runtime.h
├── wasm_runtime.c
└── Makefile

tests/
├── a_unit/              # Unit tests
├── b_integration/       # Integration tests
├── c_e2e/               # End-to-end tests
└── fixtures/            # WAT test programs
```

### 2.2 Compilation Pipeline

```
┌─────────────────┐
│  WASM Binary    │
└────────┬────────┘
         │ BinaryReader
         ▼
┌─────────────────┐
│   WasmModule    │  (Parsed AST)
│  - types        │
│  - functions    │
│  - memories     │
│  - globals      │
│  - exports      │
└────────┬────────┘
         │ compile_module()
         ▼
┌─────────────────┐
│   QBE Module    │  (IR)
│  - data defs    │
│  - functions    │
│    - blocks     │
│    - phis       │
│    - instrs     │
└────────┬────────┘
         │ emit()
         ▼
┌─────────────────┐
│    QBE IL       │  (.ssa file)
└────────┬────────┘
         │ qbe
         ▼
┌─────────────────┐
│   Assembly      │  (.s file)
└────────┬────────┘
         │ clang + runtime
         ▼
┌─────────────────┐
│   Executable    │
└─────────────────┘
```

## 3. Parser Design

### 3.1 Binary Reader

The `BinaryReader` class handles low-level binary parsing:

```python
class BinaryReader:
    def read_byte(self) -> int
    def read_u32(self) -> int      # Unsigned LEB128
    def read_s32(self) -> int      # Signed LEB128
    def read_u64(self) -> int
    def read_s64(self) -> int
    def read_f32(self) -> float
    def read_f64(self) -> float
    def read_name(self) -> str     # Length-prefixed UTF-8
    def read_value_type(self) -> ValueType
```

LEB128 (Little Endian Base 128) is WebAssembly's variable-length integer encoding, where each byte uses 7 bits for data and 1 bit as a continuation flag.

### 3.2 Type System

The `ValueType` enum represents WebAssembly value types:

```python
class ValueType(Enum):
    # Numeric types
    I32 = 0x7F
    I64 = 0x7E
    F32 = 0x7D
    F64 = 0x7C

    # Reference types (WASM 2.0)
    FUNCREF = 0x70
    EXTERNREF = 0x6F

    # GC types
    ANYREF = 0x6E
    EQREF = 0x6D
    I31REF = 0x6C
    STRUCTREF = 0x6B
    ARRAYREF = 0x6A
    NULLREF = 0x69
    # ...
```

Function types are represented as:

```python
@dataclass
class FuncType:
    params: tuple[ValueType, ...]
    results: tuple[ValueType, ...]
```

### 3.3 Module Representation

The `WasmModule` class holds the complete parsed module:

```python
@dataclass
class WasmModule:
    types: list[FuncType | StructType | ArrayType]
    imports: list[Import]
    func_types: list[int]          # Type indices for functions
    tables: list[TableType]
    memories: list[MemoryType]
    globals: list[Global]
    exports: list[Export]
    start: int | None
    elements: list[ElementSegment]
    code: list[FunctionBody]
    data: list[DataSegment]
```

## 4. Compiler Design

### 4.1 Compilation Contexts

Three context objects manage compilation state:

**ModuleContext** - Per-module state:
```python
@dataclass
class ModuleContext:
    module: WasmModule
    qbe_module: Module
    memory_base: str = "__wasm_memory"
    memory_size: str = "__wasm_memory_size"
```

**FunctionContext** - Per-function state:
```python
@dataclass
class FunctionContext:
    module: WasmModule
    func_idx: int
    func_type: FuncType
    locals: list[ValueType]
    stack: ValueStack
    control_stack: list[ControlFrame]
    local_addrs: dict[int, str]    # Stack slot addresses
    label_counter: int
```

**ControlFrame** - Per-block state:
```python
@dataclass
class ControlFrame:
    kind: str                      # "block", "loop", "if", "try"
    start_depth: int               # Stack depth at entry
    result_types: tuple[ValueType, ...]
    label_name: str                # Branch target
    else_label: str | None         # For if blocks
    end_label: str | None
    then_values: list[str] | None  # For phi nodes
    then_label: str | None
```

### 4.2 Stack-to-SSA Conversion

WebAssembly is a stack machine; QBE uses SSA with named temporaries. The `ValueStack` class bridges this gap:

```python
@dataclass
class StackValue:
    name: str          # Temporary name (e.g., "t0")
    type: ValueType

class ValueStack:
    def push(self, value: StackValue) -> None
    def pop(self) -> StackValue
    def pop_n(self, n: int) -> list[StackValue]
    def peek(self) -> StackValue
    def peek_at(self, index: int) -> StackValue
    def new_temp(self, vtype: ValueType) -> StackValue
    def depth(self) -> int
    def clone(self) -> ValueStack
    def truncate(self, depth: int) -> list[StackValue]
```

**Example transformation:**

```wasm
i32.const 5
i32.const 3
i32.add
```

Stack evolution:
```
[]           push t0=5      [t0]
[t0]         push t1=3      [t0, t1]
[t0, t1]     pop t0,t1      []
             emit add
             push t2        [t2]
```

Generated QBE IL:
```
%t0 =w copy 5
%t1 =w copy 3
%t2 =w add %t0, %t1
```

### 4.3 Control Flow Conversion

WebAssembly's structured control flow is converted to a CFG:

**block** - Forward branch target:
```wasm
(block $label
  ...
  (br $label)    ;; Jump to end
  ...
)
```
```
@block_start
    ...
    jmp @block_end
    ...
@block_end
```

**loop** - Backward branch target:
```wasm
(loop $label
  ...
  (br $label)    ;; Jump to start
  ...
)
```
```
@loop_start
    ...
    jmp @loop_start
    ...
@loop_end
```

**if/else** - Conditional branching:
```wasm
(if (result i32) (condition)
  (then (i32.const 1))
  (else (i32.const 2))
)
```
```
    jnz %cond, @then, @else
@then
    %t0 =w copy 1
    jmp @if_end
@else
    %t1 =w copy 2
    jmp @if_end
@if_end
    %t2 =w phi @then %t0, @else %t1
```

### 4.4 Local Variable Handling

Locals are stack-allocated to support mutation across control flow:

```
@entry
    %local_addr0 =l alloc4 4     ; Allocate 4 bytes
    storew %p0, %local_addr0     ; Store parameter

    ; local.get 0
    %t0 =w loadw %local_addr0

    ; local.set 0
    storew %t1, %local_addr0
```

This enables loop-carried values and proper SSA semantics for mutable variables.

### 4.5 Instruction Dispatch

The main compiler dispatches opcodes to category-specific handlers:

```python
def _compile_instruction(opcode, ctx, func, block, read_operand):
    # Control flow (block, loop, if, br, return, call)
    if result := compile_control_instruction(opcode, ...):
        return result

    # Variable access (local.get, global.set, etc.)
    if compile_variable_instruction(opcode, ...):
        return None

    # Numeric operations (add, sub, mul, div, etc.)
    if compile_numeric_instruction(opcode, ...):
        return None

    # Memory operations (load, store, grow, size)
    if compile_memory_instruction(opcode, ...):
        return None

    # Type conversions (wrap, extend, trunc, convert)
    if compile_conversion_instruction(opcode, ...):
        return None

    # Extended opcodes (0xFC, 0xFB prefixes)
    if opcode == 0xFC:
        compile_bulk_memory_instruction(...)
        compile_saturating_conversion(...)

    if opcode == 0xFB:
        compile_gc_instruction(...)
```

## 5. Instruction Categories

### 5.1 Numeric Operations

| WASM | QBE | Notes |
|------|-----|-------|
| `i32.add` | `add` | |
| `i32.sub` | `sub` | |
| `i32.mul` | `mul` | |
| `i32.div_s` | `div` | Signed division |
| `i32.div_u` | `udiv` | Unsigned division |
| `i32.rem_s` | `rem` | Signed remainder |
| `i32.rem_u` | `urem` | Unsigned remainder |
| `i32.and` | `and` | |
| `i32.or` | `or` | |
| `i32.xor` | `xor` | |
| `i32.shl` | `shl` | |
| `i32.shr_s` | `sar` | Arithmetic shift |
| `i32.shr_u` | `shr` | Logical shift |
| `i32.rotl` | runtime call | Rotate left |
| `i32.rotr` | runtime call | Rotate right |
| `i32.clz` | runtime call | Count leading zeros |
| `i32.ctz` | runtime call | Count trailing zeros |
| `i32.popcnt` | runtime call | Population count |

Comparisons produce `i32` (0 or 1):

| WASM | QBE | Notes |
|------|-----|-------|
| `i32.eq` | `ceqw` | Equal |
| `i32.ne` | `cnew` | Not equal |
| `i32.lt_s` | `csltw` | Signed less than |
| `i32.lt_u` | `cultw` | Unsigned less than |
| `i32.le_s` | `cslew` | Signed less or equal |
| `i32.le_u` | `culew` | Unsigned less or equal |
| `i32.gt_s` | `csgtw` | Signed greater than |
| `i32.gt_u` | `cugtw` | Unsigned greater than |
| `i32.ge_s` | `csgew` | Signed greater or equal |
| `i32.ge_u` | `cugew` | Unsigned greater or equal |

### 5.2 Memory Operations

Memory is accessed through a base pointer plus offset:

```python
# i32.load offset=N
addr = ctx.stack.pop()
effective_addr = __wasm_memory + addr + N
result = load_i32(effective_addr)
```

Generated QBE:
```
%base =l loadl $__wasm_memory
%offset =l extsw %addr
%ptr =l add %base, %offset
%ptr2 =l add %ptr, N
%result =w loadw %ptr2
```

### 5.3 Type Conversions

| WASM | QBE | Notes |
|------|-----|-------|
| `i32.wrap_i64` | `copy` | Truncate to 32 bits |
| `i64.extend_i32_s` | `extsw` | Sign-extend |
| `i64.extend_i32_u` | `extuw` | Zero-extend |
| `f32.demote_f64` | `truncd` | Narrow float |
| `f64.promote_f32` | `exts` | Widen float |
| `i32.trunc_f32_s` | `stosi` | Float to signed int |
| `f32.convert_i32_s` | `swtof` | Signed int to float |

### 5.4 Reference Types (WASM 2.0)

Reference types are represented as 64-bit pointers:

```python
# ref.null funcref
%t0 =l copy 0

# ref.is_null
%t1 =w ceql %ref, 0

# ref.func $idx
%t2 =l copy $__wasm_func_N
```

### 5.5 Table Operations

Tables are arrays of references:

```python
# table.get
base = load(__wasm_table)
addr = base + idx * 8
result = load(addr)

# table.set
base = load(__wasm_table)
addr = base + idx * 8
store(value, addr)
```

## 6. Runtime Library

The C runtime library provides intrinsic functions and memory management:

### 6.1 Integer Intrinsics

```c
int32_t __wasm_i32_clz(int32_t x);
int32_t __wasm_i32_ctz(int32_t x);
int32_t __wasm_i32_popcnt(int32_t x);
int32_t __wasm_i32_rotl(int32_t x, int32_t y);
int32_t __wasm_i32_rotr(int32_t x, int32_t y);
// ... and i64 variants
```

### 6.2 Float Intrinsics

```c
float __wasm_f32_abs(float x);
float __wasm_f32_ceil(float x);
float __wasm_f32_floor(float x);
float __wasm_f32_trunc(float x);
float __wasm_f32_nearest(float x);
float __wasm_f32_sqrt(float x);
float __wasm_f32_min(float x, float y);
float __wasm_f32_max(float x, float y);
float __wasm_f32_copysign(float x, float y);
// ... and f64 variants
```

### 6.3 Memory Management

```c
// Linear memory
extern uint8_t* __wasm_memory;
extern size_t __wasm_memory_size;

int32_t __wasm_memory_grow(int32_t pages);
int32_t __wasm_memory_size_pages(void);
```

### 6.4 Traps

```c
void __wasm_trap_unreachable(void);
void __wasm_trap_div_by_zero(void);
void __wasm_trap_integer_overflow(void);
void __wasm_trap_invalid_conversion(void);
void __wasm_trap_out_of_bounds(void);
void __wasm_trap_null_reference(void);
```

## 7. Error Handling

The compiler defines a hierarchy of errors:

```python
class WasmError(Exception):
    """Base exception for all WASM-related errors."""
    pass

class ParseError(WasmError):
    """Error during WASM binary parsing."""
    offset: int  # Byte offset in input

class ValidationError(WasmError):
    """Error during type/control flow validation."""
    pass

class CompileError(WasmError):
    """Error during code generation."""
    pass

class TrapError(WasmError):
    """Runtime trap condition."""
    pass
```

## 8. CLI Interface

```
usage: waq [-h] [-o OUTPUT] [-t TARGET] [--emit {qbe,asm,obj}] [-v]
             [--version] input

WAQ - WebAssembly to QBE Compiler

positional arguments:
  input                 Input WASM file

options:
  -h, --help            show this help message and exit
  -o, --output OUTPUT   Output file (default: input.ssa)
  -t, --target TARGET   Target: amd64_sysv, amd64_apple, arm64,
                        arm64_apple, rv64
  --emit {qbe,asm,obj}  Output format (default: qbe)
  -v, --verbose         Verbose output
  --version             Show version
```

### 8.1 Full Compilation Pipeline

```bash
# Compile WAT to WASM
wat2wasm program.wat -o program.wasm

# Compile WASM to QBE IL
waq program.wasm -o program.ssa

# Compile QBE IL to assembly
qbe -o program.s program.ssa

# Link with runtime
clang -o program program.s runtime/wasm_runtime.c

# Run
./program
```

## 9. Testing

### 9.1 Test Structure

Tests follow a pyramid structure:

| Directory | Marker | Description |
|-----------|--------|-------------|
| `tests/a_unit/` | `@pytest.mark.unit` | Fast, isolated tests |
| `tests/b_integration/` | `@pytest.mark.integration` | Component interaction |
| `tests/c_e2e/` | `@pytest.mark.e2e` | Full pipeline tests |

### 9.2 E2E Test Programs

WAT fixture programs in `tests/fixtures/`:

| File | Description | Expected Result |
|------|-------------|-----------------|
| `return_42.wat` | Return constant | 42 |
| `add.wat` | Addition | 30 |
| `locals.wat` | Local variables | 30 |
| `loop.wat` | Sum 1 to 10 | 55 |
| `factorial.wat` | factorial(6) | 720 % 256 = 208 |
| `fibonacci.wat` | fib(10) | 55 |
| `memory.wat` | Memory ops | 100 |
| `global.wat` | Global counter | 3 |

### 9.3 Running Tests

```bash
# All tests
make test

# By category
pytest -m unit
pytest -m integration
pytest -m e2e

# With coverage
make test-cov
```

## 10. Implementation Status

### 10.1 Completed Features (Stage 1)

- WASM 1.0 binary parsing
- All numeric operations (i32, i64, f32, f64)
- Memory load/store with all widths
- Local and global variables
- Control flow (block, loop, if, br, br_if, br_table)
- Function calls (direct and indirect)
- Basic type conversions
- Stack-allocated locals for loop-carried values
- Phi nodes for if/else with results

### 10.2 In Progress (Stage 2)

- Reference types (funcref, externref)
- Table operations
- Bulk memory operations
- Sign extension operators
- Saturating type conversions

### 10.3 Planned (Stage 3+)

- Multi-value returns
- Exception handling
- GC proposal (structs, arrays)
- Tail calls
- SIMD operations

## 11. Design Decisions

### 11.1 Stack-Allocated Locals

We chose stack allocation over SSA phi nodes for locals because:
- Simpler implementation
- Matches how C compilers handle mutable variables
- QBE can optimize to registers when beneficial

### 11.2 No Validation Pass

Currently, validation is minimal and interleaved with parsing. A separate validation pass would:
- Catch more errors before code generation
- Enable better error messages
- Allow type-directed optimizations

### 11.3 qbepy Library

We use the `qbepy` library for QBE IL generation rather than string manipulation:
- Type-safe IR construction
- Automatic prefix handling (`$`, `%`, `@`)
- Structured representation

## 12. References

1. WebAssembly Specification 3.0 - https://webassembly.github.io/spec/
3. QBE IL Documentation - https://c9x.me/compile/doc/il.html

## Appendix A: Example Compilation

### Input (factorial.wat)

```wat
(module
  (func $factorial (param $n i32) (result i32)
    (if (result i32) (i32.le_s (local.get $n) (i32.const 1))
      (then (i32.const 1))
      (else
        (i32.mul
          (local.get $n)
          (call $factorial (i32.sub (local.get $n) (i32.const 1)))
        )
      )
    )
  )
  (func (export "wasm_main") (result i32)
    (call $factorial (i32.const 6))
  )
)
```

### Output (factorial.ssa)

```
function w $__wasm_func_0(w %p0) {
@entry
    %local_addr0 =l alloc4 4
    storew %p0, %local_addr0
    %t0 =w loadw %local_addr0
    %t1 =w copy 1
    %t2 =w cslew %t0, %t1
    jnz %t2, @then0, @else1
@then0
    %t3 =w copy 1
    jmp @if_end2
@else1
    %t4 =w loadw %local_addr0
    %t5 =w loadw %local_addr0
    %t6 =w copy 1
    %t7 =w sub %t5, %t6
    %t8 =w call $__wasm_func_0(w %t7)
    %t9 =w mul %t4, %t8
    jmp @if_end2
@if_end2
    %t10 =w phi @then0 %t3, @else1 %t9
    ret %t10
}

export
function w $wasm_main() {
@entry
    %t0 =w copy 6
    %t1 =w call $__wasm_func_0(w %t0)
    ret %t1
}
```
